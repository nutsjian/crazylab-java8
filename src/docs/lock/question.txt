1、什么是乐观锁
----------------------------------------
    就是假设不会发生并发冲突，冲突失败就重试，直到成功为止。这个有可能会带来ABA问题。
    Java中典型的乐观锁就是 CAS（Compare and Swap），比较并操作，比如 AtomicInteger AtomicLong

2、什么是CAS的ABA问题
----------------------------------------
    1. ABA 问题：
    比如两个线程：
    线程1 查询A的值为a，与旧值a比较，
    线程2 查询A的值为a，与旧值a比较，相等，更新为b值
    线程2 查询A的值为b，与旧值b比较，相等，更新为a值
    线程1 相等，更新B的值为c

    可以看到这样的情况下，线程1 可以正常 进行CAS操作，将值从a变为c 但是在这之间，实际A值已经发了a->b  b->a的转换

    仔细思考，这样可能带来的问题是，如果需要关注A值变化过程，是会漏掉一段时间窗口的监控

    2. 来一个实际一点的问题：
    今天偶然看到一个ABA问题可能带来的问题
    小明在提款机，提取了50元，因为提款机问题，
    有两个线程，同时把余额从100变为50
    线程1（提款机）：获取当前值100，期望更新为50，
    线程2（提款机）：获取当前值100，期望更新为50，
    线程1成功执行，线程2某种原因block了，这时，某人给小明汇款50
    线程3（默认）：获取当前值50，期望更新为100，
    这时候线程3成功执行，余额变为100，
    线程2从Block中恢复，获取到的也是100，compare之后，继续更新余额为50！！！
    此时可以看到，实际余额应该为100（100-50+50），但是实际上变为了50（100-50+50-50）
    这就是ABA问题带来的成功提交

    3. 如何解决？
    不是更新某个引用的值，而是更新两个值，包括一个引用和一个版本号，即使这个值由A变成B，然后由B变成A，版本号是不同的。
    比如 AtomicStampedReference、AtomicMarkableReference

    4. CAS高并发问题
    在非常高的并发下，compareAndSet会很大概率失败，因此导致了此处CPU不断的自旋，对CPU资源造成浪费。
    解决方案：针对这样的情况，我们可以适当的对线程park，减少多线程竞争导致的频繁CAS失败，具体park的时间需要自行测试。见：BetterAtomic

    5. CAS 缺陷
    （1）循环时间太长
    （2）只能保证一个共享变量原子操作
    （3）ABA问题

3 乐观锁在 MySQL 中的运用
----------------------------------------
http://www.hollischuang.com/archives/934


