CopyOnWriteArrayList
原理：
=====================================================================================================
1. Copy-On-Write，是一种用于程序设计中的优化策略，其基本思路是，从一开始大家都在共享同一个内容，
当某个人想要修改这个内容的时候，才会真正把内容 Copy 出去形成一个新的内容然后再改，这是一种延时懒惰
策略。
2. 写的时候使用锁，并且会复制一份新的数组，因为读的地方是不加锁的。这种是用空间换时间，而且在读的
时候不能保证实时性，只能保证最终一致性。所以，你如果希望写入的数据，马上能读到，请不要使用 CopyOnWrite
容器
3. CopyOnWriteArrayList 容器是 Collections.synchronizedList(List list) 的替代方案。

优点：
=====================================================================================================
1. 允许并发读，读操作是无锁的，性能较高
2. 对于写操作，
3. 采用读写分离方式，读的效率非常高
4. CopyOnWriteArrayList 的迭代器是基于创建时的数据快照的，故数组的增删改不会影响到迭代器

缺点：
=====================================================================================================
1. 内存占用高，每次执行写操作都要将原来容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC
2. 无法保证实时性，写和读分别作用在新老不同机器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据，即会发生脏读。
这里又个疑问？
private transient volatile Object[] array;
可以看到 array 数组是通过 volatile 修饰的啊，在写操作的时候，为什么需要复制一份数据出来，然后再setArray呢？
答案：原因是 volatile 修饰的仅仅是引用，数组中元素的修改是不能保证可见性的，因此我们需要复制一份数组元素，然后添加元素后重新修改 volatile
的引用，才能达到 happens-before，线程可见性。



使用场景：
=====================================================================================================
1. 读多写少
2. 数据内容变化比较少（最好初始化时就进行加载数据到 CopyOnWriteArrayList 中）


线程安全/非线程安全
=====================================================================================================
1. Vector 线程安全，使用的 synchronized 来保证线程安全，适合写多的场景，替代 ArrayList 的非线程安全
2. CopyOnWriteArrayList，线程安全，读是无锁操作，效率高。写的时候会复制一份内存，所以是空间换时间。但是不保证数据实时性，
只保证数据最终一致性，写多的场景不适用，因为内存占用高。


