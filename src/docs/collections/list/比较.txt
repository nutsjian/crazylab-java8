ArrayList
    1. 按数组下标访问元素：get(i)、set(i, e) 的性能很高，这是数组的基本优势
    2. 如果按下标插入元素、删除元素：add(i, e)、remove(i)、remove(e)，则要用 System.arraycopy() 来赋值移动部分受影响的元素，性能就变差了
    3. 越是前面的元素，修改时要移动的元素越多。直接在数组末尾加入元素，常用 add(e)、删除最后一个元素则无影响

LinkedList
    1. 双向链表实现，链表容量无限制，每个元素都需要构造额外的 Node 对象，因此需要更多的内存
    2. 按下标访问：get(i)、set(i, e)，需要部分遍历链表，将指针移动到位（如果 i > 数组的大小的一般，会从末尾移动寻找）
    3. 插入：add() 相当于 addLast()
             addFirst()
             这几个操作，即在链表两头的操作会很简单，只需要将头、尾结点的指针修改一下即可

             add(i, e) 会检查下标 i 是否是当前 size，如果是的话，只要 addLast 即可，否则会带来部分遍历，找到 i 索引的结点，并修改结点的前后指针
    4. 删除：remove(e)、remove(i)，这两个删除都需要部分遍历，将指针移动到需要删除的位置，但是不需要 System.arraycopy()来对元素进行移位，
    只需要修改前后结点的指针即可（next、prev)

CopyOnWriteArrayList
    1. 并发优化的 ArrayList，线程安全，但是数据不是保证实时一致性，只能保证最终一致性
    2. 读操作不加锁，性能好（读读不互斥、读写不互斥、写写之间会加锁互斥）
    3. 写操作会加锁，并且会拷贝一个副本，修改好后再设置到新数组中
    4. 适合读多写少的应用场景，且对数据的实时一致性没有要求


通病：
    contains(e)、indexOf(e)、remove(e)，这些方法都需要通过遍历寻找