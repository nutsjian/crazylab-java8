[1]
1. 类加载
    是指将类的 .class 文件中的二进制数据读取到内存中，将其方法运行时数据区的方法区内，然后在堆内创建一个 java.lang.Class 对象，用
来封装类在方法区内的数据结构。类加载最终的产品是位于堆区中的 Class 对象，Class 对象封装了类在方法区内的数据结构，并且向 Java 程序员提供了
访问方法区内的数据结构的接口。

2. 加载 .class 文件的方式
    2.1 从本地系统中直接加载
    2.2 通过网络下载 .class 文件
    2.3 从 zip，jar 等归档文件中加载 .class 文件
    2.4 从专有数据库中提取 .class 文件
    2.5 将 Java 源文件动态编译为 .class 文件

3. 类的生命周期
    加载（Loading） -> 验证（Verification） -> 准备（Preparation） -> 解析（Resolution） -> 初始化（Initialization） -> 使用（Using） -> 卸载（Unloading）

    其中：加载、验证、准备、解析、初始化 这五个阶段称为 类加载过程。

    加载阶段（Loading），虚拟机需要完成以下 3 件事：
    1. 通过一个类的全限定名来获取定义此类的二进制字节流
    2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
    3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类各种数据的访问入口

    在加载阶段，开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义类加载器来完成加载。

    连接阶段（linking）
        1. 验证：是连接阶段的第一步，目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会尾号虚拟机自身的安全。验证阶段大致会完成 4 个阶段
        的校验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。
        2. 准备：为类的 静态变量 分配内存，并将其初始化为默认值。注意一下几点：
            2.1 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 heap 中
            2.2 这里所设置的初始值通常情况下是数据类型默认的零值（0、0L、null、false等），而不是被在Java代码中被显示地赋予的值

            举例：public static int value = 3;
            变量 value 在准备阶段过后的初始值为 0，而不是 3，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的 public static 指令是在程序编译后，存放于
            类构造器<clinit>() 方法之中的，所以把 value 赋值为 3 的动作将在初始化阶段才会执行。

            2.3 如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值

            举例：public static final int value = 3;
            编译时，javac 会将 value 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 的设置将 value 设置为 3。
            我们可以理解为 static final 常量在编译器就将其结果放入了调用它的类的常量池中

        3. 解析：把类中的符号引用转换为直接引用

    初始化阶段（initialization）
        类初始化是类加载过程的最后一个阶段，在这个阶段，才真正开始执行类中的 Java 程序代码。
        虚拟机规范规定了有且只有以下四种情况必须立即对类进行初始化：
        1. 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类还没有初始化，则需要先触发其初始化。
        而生成这四条指令最常见的 Java 代码场景分别是：
            new：使用 new 关键字实例化对象时
            getstatic：读取一个类的静态字段时（static）
            putstatic：设置一个类的静态字段（static）
            invokestatic：调用一个类的静态方法
            其中 getstatic、putstatic 中，当变量同时被 static 和 final 修饰，则该字段已经在编译期把结果放入常量池，这些字段除外（不会触发初始化）

        2. 使用 java.lang.refect 包的方法对类进行反射调用时，如果类还没有进行初始化过，则需要先触发其初始化
        3. 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化
        4. 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类

        以上四种情况时虚拟机规定的触发条件，称为对一个类的主动引用。除此之外所有引用类的方式都不会触发其初始化，称为被动引用。
















